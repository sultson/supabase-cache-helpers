import { Callout, Tabs, Tab } from "nextra-theme-docs";

# Queries

<Callout emoji="⚠️ ">
  Unforunately, we require you to be explicit in the select statement fields,
  and not use a wildcard ('*'), since mutations need to know the columns to
  derive whether the query cache should be updated with new values. Note that
  the wildcard selector is not allowed on any level, so you can't use it for
  relations either.
</Callout>

The cache helpers query hooks wrap the data fetching hooks of the cache libraries and pass both the cache key and the fetcher function from on the PostgREST query. This is enabled primarily by a parser that turns any Supabase PostgREST query into a definite cache key. For example,

```ts
client
  .from("contact")
  .select("id,username,ticket_number", { count: "exact" })
  .eq("username", "psteinroe");
```

is parsed into

<Tabs items={["SWR", "React Query"]}>
  <Tab>
    `postgrest$null$public$contact$select=id%2Cusername%2Cticket_number&username=eq.psteinroe$null$count=exact$head=false$`
  </Tab>
  <Tab>
    `[ 'postgrest', 'null', 'public', 'contact',
    'select=id%2Cusername%2Cticket_number&username=eq.psteinroe', 'null',
    'count=exact', 'head=false', '' ]`
  </Tab>
</Tabs>

## `useQuery`

Wrapper around the default data fetching hook that returns the query including the count without any modification of the data. The config parameter of the respective library can be passed as the second argument.

<Tabs items={['SWR', 'React Query']}>
  <Tab>
    ```tsx
    import { useQuery } from "@supabase-cache-helpers/postgrest-swr";

    const client = createClient<Database>(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_ANON_KEY
    );

    function Page() {
      const { data, count } = useQuery(
        client
          .from("contact")
          .select("id,username,ticket_number", { count: "exact" })
          .eq("username", "psteinroe"),
        {
          revalidateOnFocus: false,
          revalidateOnReconnect: false,
        }
      );
      return <div>...</div>;
    }
    ```

  </Tab>
  <Tab>
    ```tsx
    import { useQuery } from "@supabase-cache-helpers/postgrest-react-query";

    const client = createClient<Database>(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_ANON_KEY
    );

    function Page() {
      const { data, count } = useQuery(
        client
          .from("contact")
          .select("id,username,ticket_number", { count: "exact" })
          .eq("username", "psteinroe"),
        {
          enabled: false
        }
      );
      return <div>...</div>;
    }
    ```

  </Tab>
</Tabs>

## `useInfiniteOffsetPaginationQuery`

Wrapper around the infinite hooks that transforms the data into pages and returns helper functions to paginate through them. The `range` filter is automatically applied based on the `pageSize` parameter. The respective configuration parameter can be passed as second argument.

`nextPage()` and `previousPage()` are `undefined` if there is no next or previous page respectively. `setPage` allows you to jump to a page.

The hook does not use a count query and therefore does not know how many pages there are in total. Instead, it queries one item more than the `pageSize` to know whether there is another page after the current one.

<Tabs items={['SWR', 'React Query']}>
  <Tab>
    ```tsx
    import { useInfiniteOffsetPaginationQuery } from '@supabase-cache-helpers/postgrest-swr';
    import { createClient } from '@supabase/supabase-js';
    import { Database } from './types';

    const client = createClient<Database>(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_ANON_KEY
    );

    function Page() {
      const {
        currentPage,
        nextPage,
        previousPage,
        setPage,
        pages,
        pageIndex,
        isValidating,
        error,
      } = useInfiniteOffsetPaginationQuery(
        client
          .from('contact')
          .select('id,username')
          .order('username', { ascending: true }),
        { pageSize: 1, revalidateOnReconnect: true }
      );
      return <div>...</div>;
    }
    ```

  </Tab>
  <Tab>
  ```tsx
  // not supported yet :(
  ```
  </Tab>
</Tabs>

## `useOffsetInfiniteScrollQuery`

Wrapper around the infinite hooks that transforms the data into a flat list and returns a `loadMore` function. The `range` filter is automatically applied based on the `pageSize` parameter. The `SWRConfigurationInfinite` can be passed as second argument.

`loadMore()` is `undefined` if there is no more data to load.

The hook does not use a count query and therefore does not know how many items there are in total. Instead, it queries one item more than the `pageSize` to know whether there is more data to load.

<Tabs items={['SWR', 'React Query']}>
  <Tab>
    ```tsx
    import { useOffsetInfiniteScrollQuery } from '@supabase-cache-helpers/postgrest-swr';
    import { createClient } from '@supabase/supabase-js';
    import { Database } from './types';

    const client = createClient<Database>(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_ANON_KEY
    );

    function Page() {
      const { data, loadMore, isValidating, error } = useOffsetInfiniteScrollQuery(
        client
          .from('contact')
          .select('id,username')
          .order('username', { ascending: true }),
        { pageSize: 1 }
      );
      return <div>...</div>;
    }
    ```

  </Tab>
  <Tab>
  ```tsx
  // not supported yet :(
  ```
  </Tab>
</Tabs>

## `useCursorInfiniteScrollQuery`

<Callout emoji="⚠️">
  After using this hook in production, a few subtile issues were discovered.
  Please use it with caution. While improving the stability, I might introduce
  breaking changes.
</Callout>

Similiar to `useOffsetInfiniteScrollQuery`, but instead of using the `offset` filter to paginate, it uses a cursor. You can find a longer rationale on why this is more performant than offset-based pagination [here](https://the-guild.dev/blog/graphql-cursor-pagination-with-postgresql#).

For the cursor pagination to work, the query _has to have_:

- an `order` clause that defines the column and direction in which to paginate
- a `limit` clause that defines page size.

`loadMore()` is `undefined` if there is no more data to load.

The hook does not use a count query and therefore does not know how many items there are in total. You can pass `until`, to define until what value data should be loaded. If `until` is not defined, `loadMore` will always be truthy if the last page had a number of elements equal to the page size.

<Tabs items={['SWR', 'React Query']}>
  <Tab>
    ```tsx
    import { useCursorInfiniteScrollQuery } from '@supabase-cache-helpers/postgrest-swr';
    import { createClient } from '@supabase/supabase-js';
    import { Database } from './types';

    const client = createClient<Database>(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_ANON_KEY
    );

    function Page() {
      const { data, loadMore, isValidating, error } =
        useCursorInfiniteScrollQuery(
          client
            .from('contact')
            .select('id,username')
            .ilike('username', `${testRunPrefix}%`)
            .order('username', { ascending: true })
            .limit(1),
          { path: 'username' },
          { revalidateOnFocus: false }
        );

      return <div>...</div>;
    }
    ```

  </Tab>
  <Tab>
  ```tsx
  // not supported yet :(
  ```
  </Tab>
</Tabs>

## `useOffsetInfiniteQuery`

Wrapper around the infinite hook that returns the query without any modification of the data.

<Tabs items={['SWR', 'React Query']}>
  <Tab>
    ```tsx
    import { useOffsetInfiniteQuery } from '@supabase-cache-helpers/postgrest-swr';
    import { createClient } from '@supabase/supabase-js';
    import { Database } from './types';

    const client = createClient<Database>(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_ANON_KEY
    );

    function Page() {
      const { data, size, setSize, isValidating, error, mutate } = useOffsetInfiniteQuery(
        client
          .from('contact')
          .select('id,username')
          .order('username', { ascending: true }),
        { pageSize: 1 }
      );
      return <div>...</div>;
    }
    ```

  </Tab>
  <Tab>
  ```tsx
  // not supported yet :(
  ```
  </Tab>
</Tabs>
